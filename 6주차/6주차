project 1 [카운터] 앱 만들기 ~ 6. 라이프 사이클과 리액트 개발자 도구

컴포넌트 단위로 생각하기
3개의 컴포넌트 : App, Viewer, Controller component
App: viewer Controller를 감싸는 컴포넌트
Viewer : 현재의 컴포넌트를 표시함
Controller : 카운트를 제어할 수 있는 기능을 제공함.

UI : 사용자 인터페이스, 사용자와 상호작용하는 요소를 말함.

컴포넌트 스타일링 하기 
body {
  padding: 20px;
}

.App {
  margin: 0 auto;
  width: 500px;
}

.App > section { ①
  padding: 20px;
  background-color: rgb(245, 245, 245);
  border: 1px solid rgb(240, 240, 240);
  border-radius: 5px;
  margin-bottom: 10px;
}

$ App > section은 className=App 요소의 <section> 태그를 가리키는 CSS 문법, App 컴포넌트 최상위 태그 바로 아래의 <section>에만 적용!!

State를 이용해 카운터 기능 구현하기
- 이벤트가 발생했을때 컴포넌트 값을 동적으로 렌더링하려면 리액트의  State를 사용해야함!
controller 컴포넌트 버튼 클릭 -> 변경된 state 값 viewer 컴포넌트에 전달 -> 업데이트

State 컴포넌트는 App 컴포넌트에 만들어야함!
why? 부모 자식 관계로만 가능하기 때문!

Ex)
import "./App.css";
import { useState } from "react";
import Controller from "./component/Controller";
import Viewer from "./component/Viewer";

function App() {
  const [count, setCount] = useState(0);
  const handleSetCount = (value) => {
    setCount(count + value);
  };

  return (
    <div className="App">
      <h1>Simple Counter</h1>
      <section>
        <Viewer count={count} /> ①
      </section>
      <section>
        <Controller handleSetCount={handleSetCount} /> ②
      </section>
    </div>
  );
}
export default App;


const Viewer = ({ count }) => {
  return (
    <div>
      <div>현재 카운트 : </div>
      <h1>{count}</h1>
    </div>
  );
};
export default Viewer;

const Controller = ({ handleSetCount }) => {
  return (
    <div>
      <button onClick={() => handleSetCount(-1)}>-1</button>
      <button onClick={() => handleSetCount(-10)}>-10</button>
      <button onClick={() => handleSetCount(-100)}>-100</button>
      <button onClick={() => handleSetCount(100)}>+100</button>
      <button onClick={() => handleSetCount(10)}>+10</button>
      <button onClick={() => handleSetCount(1)}>+1</button>
    </div>
  );
};
export default Controller;

State 값이나 set 함수를 상위 컴포넌트에서 관리하는 것 = State 끌어올리기

리액트답게 설계하기 
데이터를 전달할때는 props 사용! 전달방향은 언제나 부모->자식, '단방향 데이터 흐름'
반면, State를 변경하는 이벤트는 자식 -> 부모, 역방향

정리하면, 데이터 : 부모 -> 자식
        이벤트 : 자식 -> 부모
        
ch.6

리액트 컴포넌트의 라이프 사이클 
마운트,업데이트,언마운트

마운트 : 컴포넌트를 페이지에 처음 렌더링할 때
업데이트 : State나 Props의 값이 바뀌거나 부모 컴포넌트가 리렌더해 자신도 리렌더될 때
언마운트 : 더 이상 페이지에 컴포넌트를 렌더링하지 않을 때

라이프 사이클 제어  : 유용한 작업을 단계에 맞게하는 

useEffect : 어떤 값이 변경될 때마다 특정 코드를 실행하는 리액트 훅

useEffect의 용법
useEffect(callback, [deps])
          콜백 함수 의존성 배열

두 번째 인수로 전달한 배열을 deps, 이 배열 요소의 값이 변경되면 첫 번째 인수로 전달한 콜백함수를 실행한다!

$$페이지에서 새로고침(<F5>) 키를 누르면 프로젝트 페이지 와 콘솔 모두 초기화, 

컴포넌트의 마운트 제어하기
컴포넌트의 마운트 제어 : 컴포넌트의 마운트 시점에 실행되는 코드를 작성하는 것

컴포넌트의 언마운트 제어하기
: 컴포넌트가 페이지에서 제거될 때

클린업 : 함수가 실행되고 종료된 후에, 미처 정리하지 못한 사항을 처리하는 일.
console.log("클린업");

리액트 개발자 도구
why? useEffect,state 값 수정 여러번 번거롭기에 사용!

